from typing import Any, List
from dataclasses import dataclass


@dataclass
class Node:
    name: str
    parent: Any  # node
    children: List  # list of nodes
    filetype: str
    size: int

    def print_children_names(self):
        for child in self.children:
            print(child.name)

    def add_children(self, data: str, children_name: str):
        filetype = get_filetype(data)
        size = get_size_based_on_filetype(filetype, data)
        new_child = Node(
            name=children_name,
            parent=self,
            children=[],
            filetype=filetype,
            size=size,
        )
        self.children.append(new_child)

    def print_tree_given_starting_node(self, indent=''):  # recursive
        print(f'{indent}-{self.filetype}', self.name, self.size)
        indent += '  '
        for child in self.children:
            child.represent_tree(indent)

    def represent_tree(self, indent=''):  # recursive
        print(f'{indent}-{self.filetype}', self.name, self.size)
        indent += '  '
        for child in self.children:
            child.represent_tree(indent)

    def update_folder_size(self) -> int:  # recursive
        if self.filetype == 'file':
            return self.size
        folder_size = 0
        for child in self.children:
            folder_size += child.update_folder_size()
        self.size = folder_size
        return folder_size

    def get_combined_sum_of_folders_greater_than(self, minimum_size: int) -> int:  # recursive
        if self.filetype == 'file':
            return 0
        count_of_children = 0
        for child in self.children:
            count_of_children += child.get_combined_sum_of_folders_greater_than(minimum_size)
        if self.name == '/':
            return count_of_children  # end!
        if minimum_size > self.size:
            count_of_children += self.size
        return count_of_children

    def get_list_of_all_folder_sizes(self) -> List[int]:  # recursive
        if self.filetype == 'file':
            return [0]
        size_of_down_folders = []
        for child in self.children:
            size_of_down_folders += child.get_list_of_all_folder_sizes()
        size_of_down_folders.append(self.size)
        return list(set(size_of_down_folders))

    def get_size_of_folder_closest_to(self, target_size_to_delete: int):
        all_folder_sizes = self.get_list_of_all_folder_sizes()  # get a list of all folder sizes
        all_folder_sizes = sorted(all_folder_sizes)  # sort

        final_size = 0
        for folder_size in all_folder_sizes:
            final_size = folder_size
            if folder_size > target_size_to_delete:
                # we found the folder just bigger than the target to delete!
                break
        return final_size


def find_folder_size_with_smallest_positve_difference(
    folder_sizes: List[int], target_size: int
) -> int:
    folder_sizes = sorted(folder_sizes)  # sort
    final_size = 0
    for folder_size in folder_sizes:
        final_size = folder_size
        if folder_size > target_size:
            # we found the folder just bigger than the target to delete!
            break
    return final_size


def read_input_as_lines(input_path: str) -> List[str]:
    with open(input_path) as f:
        lines = f.readlines()
    lines = [line.strip() for line in lines]
    return lines


def get_node(list_of_nodes: List[Node], node_name: str):
    for node in list_of_nodes:
        if node.name == node_name:
            return node
    raise Exception(f'Node {node_name} not found in {list_of_nodes}')


def execute_cd_command(node: Node, argument: str):
    if argument == '..':
        return node.parent
    return get_node(node.children, argument)


def get_filetype(data: str) -> str:
    if data == 'dir':
        return 'dir'
    return 'file'


def get_size_based_on_filetype(filetype: str, data: str):
    if filetype == 'file':
        return int(data)
    return 0


def get_root(node: Node):
    while True:
        node = node.parent
        if node.parent == None:
            return node


def initialize_tree_node_given_input(input: List[str]):
    input.pop(0)
    node = Node('/', None, [], 'dir', 0)
    for line in input:
        line = line.split(' ')
        if line[0] == '$':
            if line[1] == 'cd':
                node = execute_cd_command(node, line[2])
                continue
            elif line[1] == 'ls':
                continue
        node.add_children(line[0], line[1])
    node = get_root(node)
    return node


def main():
    input = read_input_as_lines('input.txt')
    node = initialize_tree_node_given_input(input)
    node.update_folder_size()  # folders have no size, update based on folder contents
    node.print_tree_given_starting_node()
    combined_sum = node.get_combined_sum_of_folders_greater_than(minimum_size=100_000)

    target_size_to_delete = 30_000_000 - 70_000_000 + node.size
    folder_sizes = node.get_list_of_all_folder_sizes()
    folder_size_to_delete = find_folder_size_with_smallest_positve_difference(
        folder_sizes, target_size_to_delete
    )
    print(f'Combined sum {combined_sum}')
    print(f'Size of folder to delete {folder_size_to_delete}')


if __name__ == '__main__':
    main()
